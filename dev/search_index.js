var documenterSearchIndex = {"docs":
[{"location":"public/forcefields/#Force-fields","page":"Force fields","title":"Force fields","text":"","category":"section"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"Pages = [\"forcefields.md\"]","category":"page"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"update!\nread_ball_ini_file","category":"page"},{"location":"public/forcefields/#BiochemicalAlgorithms.update!","page":"Force fields","title":"BiochemicalAlgorithms.update!","text":"Update the internal data structures of the force field when the system changes    (e.g., through coordinate updates)\n\nPlease note that changes to the options or the topology require a call to setup!prior to the call toupdate``.\n\n\n\n\n\n","category":"function"},{"location":"public/forcefields/#BiochemicalAlgorithms.read_ball_ini_file","page":"Force fields","title":"BiochemicalAlgorithms.read_ball_ini_file","text":"read_ball_ini_file(path::String; ...) -> BALLIniFile\nread_ball_ini_file(\n    path::String,\n    T;\n    cleanup_keys\n) -> BALLIniFile\n\n\nRead a file in BALL's old Ini file format and return it as a BALLIniFile.\n\nIf cleanup_keys is set to true (the default), keys into the Ini sections are simplified (e.g., ver:version becomes version, key:I becomes I, ...).\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#Mappings","page":"Mappings","title":"Mappings","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"Pages = [\"mappings.md\"]","category":"page"},{"location":"public/mappings/#Atom-bijection","page":"Mappings","title":"Atom bijection","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"AbstractAtomBijection\nTrivialAtomBijection","category":"page"},{"location":"public/mappings/#BiochemicalAlgorithms.AbstractAtomBijection","page":"Mappings","title":"BiochemicalAlgorithms.AbstractAtomBijection","text":"abstract type AbstractAtomBijection{T}\n\nAbstract base type for AtomBijections.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.TrivialAtomBijection","page":"Mappings","title":"BiochemicalAlgorithms.TrivialAtomBijection","text":"TrivialAtomBijection{T} <: AbstractAtomBijection{T}\n\nMutable representation of a bijection of atoms based on the order of atoms in the individual atom containers.\n\nPublic fields\n\natoms_A::AtomTable{T}\natoms_B::AtomTable{T}\n\nConstructors\n\nTrivialAtomBijection{T}(A::AbstractAtomContainer{T}, B::AbstractAtomContainer{T}) where T\n\nCreates a new TrivialAtomBijection{T} with the atoms of the individual atom containers. \n\nTrivialAtomBijection{T}(atoms_A, B::AbstractAtomContainer{T}) where T\n\nCreates a new TrivialAtomBijection{T}based on the unique set of atom numbers of atoms_A.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#Rigid-Mapping","page":"Mappings","title":"Rigid Mapping","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"AbstractRMSDMinimizer\nRMSDMinimizerCoutsias\nRMSDMinimizerKabsch\nRigidTransform\ncompute_rmsd\ncompute_rmsd_minimizer\nmap_rigid!\nmatch_points\nrigid_transform!\ntranslate!","category":"page"},{"location":"public/mappings/#BiochemicalAlgorithms.AbstractRMSDMinimizer","page":"Mappings","title":"BiochemicalAlgorithms.AbstractRMSDMinimizer","text":"abstract type AbstractRMSDMinimizer\n\nAbstract base type for rmsd minimizer.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RMSDMinimizerCoutsias","page":"Mappings","title":"BiochemicalAlgorithms.RMSDMinimizerCoutsias","text":"abstract type RMSDMinimizerCoutsias <: AbstractRMSDMinimizer\n\nAbstract base type for minimizer as described by Coutsias et al., which is used as default.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RMSDMinimizerKabsch","page":"Mappings","title":"BiochemicalAlgorithms.RMSDMinimizerKabsch","text":"abstract type RMSDMinimizerKabsch <: AbstractRMSDMinimizer\n\nAbstract base type for minimizer as described by Kabsch.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RigidTransform","page":"Mappings","title":"BiochemicalAlgorithms.RigidTransform","text":"struct RigidTransform{T<:Real}\n\nMutable representation of a rigid transform.\n\nFields\n\nrotation::RotMatrix3\ntranslation::Vector3\n\nConstructors\n\nRigidTransform{T}(r::RotMatrix3{T}, t::Vector3{T}) where {T<:Real}\n\nCreates a new RigidTransform{T} with the given parameters.\n\nRigidTransform{T}(r::Matrix3{T}, t::Vector3{T}) where {T<:Real} \n\nCreates a new RigidTransform{T} and converts the given Matrix3{T} to a RotMatrix3 object.\n\nnote: Note\nFrom the documentation of Rotations.jl:The given Matrix3{T} should have the property I =RR^T, but this isn't enforced by the constructor.\n\nRigidTransform(r::Matrix3, t::Vector3) = RigidTransform{Float32}(r, t)\n\nCreates a new RigidTransform{Float32} with the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.compute_rmsd","page":"Mappings","title":"BiochemicalAlgorithms.compute_rmsd","text":"compute_rmsd(f::AbstractAtomBijection{T<:Real}) -> Any\n\n\nComputes the root mean square deviation (RMSD) of the given AbstractAtomBijection.\n\n\n\n\n\ncompute_rmsd(\n    A::AbstractAtomContainer,\n    B::AbstractAtomContainer\n) -> Any\n\n\nComputes the root mean square deviation (RMSD) based on two sets of atoms.\n\nnote: Note\nAtomContainers must have the same number of atoms.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.compute_rmsd_minimizer","page":"Mappings","title":"BiochemicalAlgorithms.compute_rmsd_minimizer","text":"compute_rmsd_minimizer(\n    f::AbstractAtomBijection{T<:Real}\n) -> RigidTransform\ncompute_rmsd_minimizer(\n    f::AbstractAtomBijection{T<:Real},\n    mini::Type{<:AbstractRMSDMinimizer}\n) -> RigidTransform\n\n\nComputes the transformation required to map two atom sets given as the atom bijection.\n\nReturns a RigidTransformation object. The translation is given by the difference of the means of the atom sets. The corresponding rotation matrix can be computed by the approach of Coutsias et al. (default) or Kabsch, implemented by RMSDMinimizerCoutsias and RMSDMinimizerKabsch, respectively.  Both implementation rely on solving an eigen value problem. Coutsias et al. represents rotation matrices as quaternions (use of Package Quaternions.jl).\n\nnote: Note\nIn order to map the two atom sets with the resulting RigidTransform the system to be mapped hast to be transferred to the origin first (before the RigidTransform is applied).\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.map_rigid!","page":"Mappings","title":"BiochemicalAlgorithms.map_rigid!","text":"map_rigid!(\n    A::AbstractAtomContainer{T<:Real},\n    B::AbstractAtomContainer{T<:Real};\n    heavy_atoms_only\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nMaps AbstractAtomContainer A onto AbstractAtomContainer B by first moving A to the origin and then computing the RigidTransform by using RMSDMinimizerCoutsias. Returns the mapped AbstractAtomContainer A.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.match_points","page":"Mappings","title":"BiochemicalAlgorithms.match_points","text":"match_points(\n    w1::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    w2::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    w3::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v1::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v2::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v3::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3}\n) -> Tuple{Any, Any}\n\n\nThe transformation maps\n\nthe point w1 onto the point v1 and\nthe point w2 onto the ray that starts in v1 and goes through v2\nthe point w3 into the plane generated by v1, v2 and v3\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.rigid_transform!","page":"Mappings","title":"BiochemicalAlgorithms.rigid_transform!","text":"rigid_transform!(\n    m::AbstractAtomContainer{T<:Real},\n    transform::RigidTransform{T<:Real}\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nPerforms a rigid transformation on the atom positions of m.  First, atoms are rotated by the rotation matrix of the RigidTransform r followed by translation.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.translate!","page":"Mappings","title":"BiochemicalAlgorithms.translate!","text":"translate!(\n    m::AbstractAtomContainer{T<:Real},\n    t::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3}\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nMoves the atoms of the atom container to new positions by adding the values given by the vector t the current positions.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#System-representation","page":"System representation","title":"System representation","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Pages = [\"system.md\"]","category":"page"},{"location":"public/system/#Abstract-types","page":"System representation","title":"Abstract types","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"AbstractColumnTable\nAbstractSystemComponentTable\nAbstractSystemComponent\nAbstractAtomContainer","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.AbstractColumnTable","page":"System representation","title":"BiochemicalAlgorithms.AbstractColumnTable","text":"abstract type AbstractColumnTable <: Tables.AbstractColumns\n\nAbstract base type for all Tables.jl-compatible column tables.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractSystemComponentTable","page":"System representation","title":"BiochemicalAlgorithms.AbstractSystemComponentTable","text":"abstract type AbstractSystemComponentTable{T<:Real} <: AbstractColumnTable\n\nAbstract base type for all Tables.jl-compatible system component tables.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractSystemComponent","page":"System representation","title":"BiochemicalAlgorithms.AbstractSystemComponent","text":"abstract type AbstractSystemComponent{T<:Real}\n\nAbstract base type for all components of a system, including the system itself.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractAtomContainer","page":"System representation","title":"BiochemicalAlgorithms.AbstractAtomContainer","text":"abstract type AbstractAtomContainer{T} <: AbstractSystemComponent{T}\n\nAbstract base type for all atom containers.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#Common-functions","page":"System representation","title":"Common functions","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"has_property\nget_property\nset_property!\nhas_flag\nset_flag!\nunset_flag!","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.has_property","page":"System representation","title":"BiochemicalAlgorithms.has_property","text":"has_property(\n    ac::AbstractSystemComponent,\n    key::Symbol\n) -> Any\n\n\nReturns a Bool indicating whether the given system component has the given property.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.get_property","page":"System representation","title":"BiochemicalAlgorithms.get_property","text":"get_property(\n    ac::AbstractSystemComponent,\n    key::Symbol\n) -> Any\n\n\nReturns the property associated with the given key in ac.\n\n\n\n\n\nget_property(\n    ac::AbstractSystemComponent,\n    key::Symbol,\n    default\n) -> Any\n\n\nReturns the property associated with the given key in ac. If no such property exists, returns default.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.set_property!","page":"System representation","title":"BiochemicalAlgorithms.set_property!","text":"set_property!(\n    ac::AbstractSystemComponent,\n    key::Symbol,\n    value\n) -> Any\n\n\nSets the property associated with the given key in ac to the given value.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.has_flag","page":"System representation","title":"BiochemicalAlgorithms.has_flag","text":"has_flag(ac::AbstractSystemComponent, flag::Symbol) -> Any\n\n\nReturns a Bool indicating whether the given system component has the given flag.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.set_flag!","page":"System representation","title":"BiochemicalAlgorithms.set_flag!","text":"set_flag!(ac::AbstractSystemComponent, flag::Symbol) -> Any\n\n\nAdds the given flag to ac.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.unset_flag!","page":"System representation","title":"BiochemicalAlgorithms.unset_flag!","text":"unset_flag!(\n    ac::AbstractSystemComponent,\n    flag::Symbol\n) -> Any\n\n\nRemoves the given flag from ac.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Systems","page":"System representation","title":"Systems","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"System\ndefault_system\nBase.parent(::System)\nparent_system","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.System","page":"System representation","title":"BiochemicalAlgorithms.System","text":"mutable struct System{T} <: AbstractAtomContainer{T}\n\nMutable representation of a biomolecular system.\n\nFields\n\nname::String\nproperties::Properties\nflags::Flags\n\nConstructors\n\nSystem(name::String = \"\", properties::Properties = Properties(), flags::Flags = Flags())\n\nCreates a new and empty System{Float32}.\n\nSystem{T}(name::String = \"\", properties::Properties = Properties(), flags::Flags = Flags())\n\nCreates a new and empty System{T}.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.default_system","page":"System representation","title":"BiochemicalAlgorithms.default_system","text":"default_system() -> System{Float32}\n\n\nReturns the global default system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.parent-Tuple{System}","page":"System representation","title":"Base.parent","text":"parent(::Atom)\nparent(::Bond)\nparent(::Chain)\nparent(::Fragment)\nparent(::Molecule)\nparent(::Nucleotide)\nparent(::Residue)\nparent(::System)\n\nReturns the System{T} containing the given object.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#BiochemicalAlgorithms.parent_system","page":"System representation","title":"BiochemicalAlgorithms.parent_system","text":"parent_system(::Atom)\nparent_system(::Bond)\nparent_system(::Chain)\nparent_system(::Fragment)\nparent_system(::Molecule)\nparent_system(::Nucleotide)\nparent_system(::Residue)\nparent_system(::System)\n\nReturns the System{T} containing the given object. Alias for  Base.parent.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Atoms","page":"System representation","title":"Atoms","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Atom\nAtomTable\natom_by_idx\natom_by_name\natoms\nis_bound_to\nis_geminal\nis_vicinal\nnatoms\nBase.push!(::System{T}, ::Atom{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Atom","page":"System representation","title":"BiochemicalAlgorithms.Atom","text":"Atom{T} <: AbstractSystemComponent{T}\n\nMutable representation of an individual atom in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nelement::ElementType\nname::String\natom_type::String\nr::Vector3{T}\nv::Vector3{T}\nF::Vector3{T}\nformal_charge::Int\ncharge::T\nradius::T\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nframe_id::Int\nmolecule_idx::MaybeInt\nchain_idx::MaybeInt\nfragment_idx::MaybeInt\nnucleotide_idx::MaybeInt\nresidue_idx::MaybeInt\n\nConstructors\n\nAtom(\n    ac::AbstractAtomContainer{T}\n    number::Int,\n    element::ElementType;\n    # keyword arguments\n    name::String = \"\",\n    atom_type::String = \"\",\n    r::Vector3{T} = Vector3{T}(0, 0, 0),\n    v::Vector3{T} = Vector3{T}(0, 0, 0),\n    F::Vector3{T} = Vector3{T}(0, 0, 0),\n    formal_charge::Int = 0,\n    charge::T = zero(T),\n    radius::T = zero(T),\n    properties::Properties = Properties(),\n    flags::Flags = Flags(),\n    frame_id::Int = 1\n    molecule_idx::MaybeInt = nothing,\n    chain_idx::MaybeInt = nothing,\n    fragment_idx::MaybeInt = nothing,\n    nucleotide_idx::MaybeInt = nothing,\n    residue_idx::MaybeInt = nothing\n)\n\nCreates a new Atom{T} in the given atom container.\n\nAtom(\n    number::Int,\n    element::ElementType;\n    kwargs...\n)\n\nCreates a new Atom{Float32} in the default system. Supports the same keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AtomTable","page":"System representation","title":"BiochemicalAlgorithms.AtomTable","text":"AtomTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system atoms (or a subset thereof). Atom tables can be generated using atoms or filtered from other atom tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nelement::AbstractVector{ElementType}\nname::AbstractVector{String}\natom_type::AbstractVector{String}\nr::AbstractVector{Vector3{T}}\nv::AbstractVector{Vector3{T}}\nF::AbstractVector{Vector3{T}}\nformal_charge::AbstractVector{Int}\ncharge::AbstractVector{T}\nradius::AbstractVector{T}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nframe_id::AbstractVector{Int}\nmolecule_idx::AbstractVector{MaybeInt}\nchain_idx::AbstractVector{MaybeInt}\nfragment_idx::AbstractVector{MaybeInt}\nnucleotide_idx::AbstractVector{MaybeInt}\nresidue_idx::AbstractVector{MaybeInt}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.atom_by_idx","page":"System representation","title":"BiochemicalAlgorithms.atom_by_idx","text":"atom_by_idx(sys::System{T}, idx::Int64) -> Atom\n\n\nReturns the Atom{T} associated with the given idx in sys. Throws a KeyError if no such atom exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.atom_by_name","page":"System representation","title":"BiochemicalAlgorithms.atom_by_name","text":"atom_by_name(\n    ac::AbstractAtomContainer{T},\n    name::String;\n    frame_id\n) -> Union{Nothing, Atom}\n\n\nReturns the first Atom{T} associated with the given name in ac. Returns nothing if no such atom exists.\n\nSupported keyword arguments\n\nframe_id::MaybeInt = 1: Any value other than nothing limits the result to atoms matching this frame ID.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.atoms","page":"System representation","title":"BiochemicalAlgorithms.atoms","text":"atoms(::Chain)\natoms(::Fragment)\natoms(::Molecule)\natoms(::Nucleotide)\natoms(::Residue)\natoms(::System)\n\nReturns an AtomTable{T} containing all atoms of the given atom container.\n\nSupported keyword arguments\n\nframe_id::MaybeInt = 1\nmolecule_idx::Union{MaybeInt, Some{Nothing}} = nothing\nchain_idx::Union{MaybeInt, Some{Nothing}} = nothing\nfragment_idx::Union{MaybeInt, Some{Nothing}} = nothing\nnucleotide_idx::Union{MaybeInt, Some{Nothing}} = nothing\nresidue_idx::Union{MaybeInt, Some{Nothing}} = nothing\n\nAll keyword arguments limit the results to atoms matching the given IDs. Keyword arguments set to nothing are ignored. You can use Some(nothing) to explicitly filter for ID values of nothing.\n\n\n\n\n\natoms(\n    substruct::Substructure{T, A} where A<:AbstractAtomContainer{T};\n    frame_id,\n    molecule_idx,\n    chain_idx,\n    fragment_idx,\n    nucleotide_idx,\n    residue_idx\n) -> SystemComponentTable{T, C} where {T, C<:Atom{T}}\n\n\nReturns an AtomTable for all of the given system's atoms matching the given criteria (value or missing). Fields given as nothing are ignored. The returned table contains all public and private atom fields.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_bound_to","page":"System representation","title":"BiochemicalAlgorithms.is_bound_to","text":"is_bound_to(a1::Atom, a2::Atom) -> Bool\n\n\nDecides if two atoms are bound to each other. Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_geminal","page":"System representation","title":"BiochemicalAlgorithms.is_geminal","text":"is_geminal(a1::Atom, a2::Atom) -> Union{Missing, Bool}\n\n\nDecides if two atoms are geminal.\n\nTwo atoms are geminal if they do not share a common bond but both have a bond to a third atom. For example the two hydrogen atoms in water are geminal.  Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_vicinal","page":"System representation","title":"BiochemicalAlgorithms.is_vicinal","text":"is_vicinal(a1::Atom, a2::Atom) -> Bool\n\n\nDecides if two atoms are vicinal.\n\nTwo atoms are vicinal if they are separated by three bonds (1-4 position). Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.natoms","page":"System representation","title":"BiochemicalAlgorithms.natoms","text":"natoms(::Chain)\nnatoms(::Fragment)\nnatoms(::Molecule)\nnatoms(::Nucleotide)\nnatoms(::Residue)\nnatoms(::System)\n\nReturns the number of atoms in the given atom container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Atom{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Fragment{T},   ::Atom{T})\npush!(::Molecule{T},   ::Atom{T})\npush!(::Nucleotide{T}, ::Atom{T})\npush!(::Residue{T},    ::Atom{T})\npush!(::System{T},     ::Atom{T})\n\nCreates a copy of the given atom in the given atom container. The new atom is automatically assigned a new idx.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Bonds","page":"System representation","title":"Bonds","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Bond\nBondTable\nbond_by_idx\nbonds\nnbonds\nBase.push!(::System{T}, ::Bond{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Bond","page":"System representation","title":"BiochemicalAlgorithms.Bond","text":"Bond{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual bond in a system.\n\nPublic fields\n\nidx::Int\na1::Int\na2::Int\norder::BondOrderType\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\n\nConstructors\n\nBond(\n    sys::System{T}, \n    a1::Int, \n    a2::Int, \n    order::BondOrderType;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Bond{T} in the given system.\n\nBond(\n    a1::Int,\n    a2::Int,\n    order::BondOrderType;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Bond{Float32} in the default system.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.BondTable","page":"System representation","title":"BiochemicalAlgorithms.BondTable","text":"BondTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system bonds (or a subset thereof). Bond tables can be generated using bonds or filtered from other bond tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\na1::AbstractVector{Int}\na2::AbstractVector{Int}\norder::AbstractVector{BondOrderType}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.bond_by_idx","page":"System representation","title":"BiochemicalAlgorithms.bond_by_idx","text":"bond_by_idx(sys::System{T}, idx::Int64) -> Bond\n\n\nReturns the Bond{T} associated with the given idx in sys. Throws a KeyError if no such bond exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.bonds","page":"System representation","title":"BiochemicalAlgorithms.bonds","text":"bonds(::Chain)\nbonds(::Fragment)\nbonds(::Molecule)\nbonds(::Nucleotide)\nbonds(::Residue)\nbonds(::System)\n\nReturns a BondTable{T} containing all bonds of the given atom container where at least one associated atom is contained in the same container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\nbonds(::Atom)\n\nReturns a BondTable{T} containing all bonds of the given atom.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nbonds","page":"System representation","title":"BiochemicalAlgorithms.nbonds","text":"nbonds(::Chain)\nnbonds(::Fragment)\nnbonds(::Molecule)\nnbonds(::Nucleotide)\nnbonds(::Residue)\nnbonds(::System)\n\nReturns the number of bonds in the given atom container where at least one associated atom is contained in the same container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\nnbonds(::Atom)\n\nReturns the number of bonds of the given atom.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Bond{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::AbstractAtomContainer, ::Bond{T})\n\nCreates a copy of the given bond in the system associated with the given atom container. The new bond is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Molecules","page":"System representation","title":"Molecules","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Molecule\nMoleculeTable\nmolecule_by_idx\nmolecules\nnmolecules\nparent_molecule\nBase.push!(::System{T}, ::Molecule{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Molecule","page":"System representation","title":"BiochemicalAlgorithms.Molecule","text":"Molecule{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual molecule in a system.\n\nPublic fields\n\nidx::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\n\nConstructors\n\nMolecule(\n    sys::System{T};\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Molecule{T} in the given system.\n\nMolecule(;\n    #keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Molecule{Float32} in the default system.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.MoleculeTable","page":"System representation","title":"BiochemicalAlgorithms.MoleculeTable","text":"MoleculeTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system molecules (or a subset thereof). Molecule tables can be generated using molecules or filtered from other molecule tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.molecule_by_idx","page":"System representation","title":"BiochemicalAlgorithms.molecule_by_idx","text":"molecule_by_idx(sys::System{T}, idx::Int64) -> Molecule\n\n\nReturns the Molecule{T} associated with the given idx in sys. Throws a KeyError if no such molecule exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.molecules","page":"System representation","title":"BiochemicalAlgorithms.molecules","text":"molecules(sys::System{T}) -> MoleculeTable\n\n\nReturns a MoleculeTable{T} containing all molecules of the given system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nmolecules","page":"System representation","title":"BiochemicalAlgorithms.nmolecules","text":"nmolecules(sys::System) -> Int64\n\n\nReturns the number of molecules in the given system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_molecule","page":"System representation","title":"BiochemicalAlgorithms.parent_molecule","text":"parent_molecule(::Atom)\nparent_molecule(::Chain)\nparent_molecule(::Fragment)\nparent_molecule(::Nucleotide)\nparent_molecule(::Residue)\n\nReturns the Molecule{T} containing the given object. Returns nothing if no such molecule exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Molecule{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::System{T}, ::Molecule{T})\n\nCreates a copy of the given molecule in the given system. The new molecule is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Chains","page":"System representation","title":"Chains","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Chain\nChainTable\nchain_by_idx\nchains\nnchains\nparent_chain\nBase.push!(::Molecule{T}, ::Chain{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Chain","page":"System representation","title":"BiochemicalAlgorithms.Chain","text":"Chain{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual chain in a system.\n\nPublic fields\n\nidx::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\n\nConstructors\n\nChain(\n    mol::Molecule{T};\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Chain{T} in the given molecule.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.ChainTable","page":"System representation","title":"BiochemicalAlgorithms.ChainTable","text":"ChainTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system chains (or a subset thereof). Chain tables can be generated using chains or filtered from other chain tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.chain_by_idx","page":"System representation","title":"BiochemicalAlgorithms.chain_by_idx","text":"chain_by_idx(sys::System{T}, idx::Int64) -> Chain\n\n\nReturns the Chain{T} associated with the given idx in sys. Throws a KeyError if no such chain exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.chains","page":"System representation","title":"BiochemicalAlgorithms.chains","text":"chains(::Molecule)\nchains(::System; kwargs...)\n\nReturns a ChainTable{T} containing all chains of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing: Any value other than nothing limits the result to chains belonging to the molecule with the given ID.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nchains","page":"System representation","title":"BiochemicalAlgorithms.nchains","text":"nchains(::Molecule)\nnchains(::System; kwargs...)\n\nReturns the number of chains in the given atom container.\n\nSupported keyword arguments\n\nSee chains\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_chain","page":"System representation","title":"BiochemicalAlgorithms.parent_chain","text":"parent_chain(::Atom)\nparent_chain(::Fragment)\nparent_chain(::Nucleotide)\nparent_chain(::Residue)\n\nReturns the Chain{T} containing the given object. Returns nothing if no such chain exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Molecule{T}, Chain{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Molecule{T}, ::Chain{T})\n\nCreates a copy of the given chain in the given molecule. The new chain is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Fragments","page":"System representation","title":"Fragments","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Fragment\nFragmentTable\nfragment_by_idx\nfragments\nnfragments\nparent_fragment\nBase.push!(::Chain{T}, ::Fragment{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Fragment","page":"System representation","title":"BiochemicalAlgorithms.Fragment","text":"Fragment{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual fragment in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nFragment(\n    chain::Chain{T},\n    number::Int;\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Fragment{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.FragmentTable","page":"System representation","title":"BiochemicalAlgorithms.FragmentTable","text":"FragmentTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system fragments (or a subset thereof). Fragment tables can be generated using fragments or filtered from other fragment tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.fragment_by_idx","page":"System representation","title":"BiochemicalAlgorithms.fragment_by_idx","text":"fragment_by_idx(sys::System{T}, idx::Int64) -> Fragment\n\n\nReturns the Fragment{T} associated with the given idx in sys. Throws a KeyError if no such fragment exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.fragments","page":"System representation","title":"BiochemicalAlgorithms.fragments","text":"fragments(::Chain)\nfragments(::Molecule)\nfragments(::System)\n\nReturns a FragmentTable{T} containing all fragments of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to fragments matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nfragments","page":"System representation","title":"BiochemicalAlgorithms.nfragments","text":"nfragments(::Chain)\nnfragments(::Molecule)\nnfragments(::System)\n\nReturns the number of fragments in the given atom container.\n\nSupported keyword arguments\n\nSee fragments\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_fragment","page":"System representation","title":"BiochemicalAlgorithms.parent_fragment","text":"parent_fragment(::Atom)\n\nReturns the Fragment{T} containing the given atom. Returns nothing if no such fragment exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Fragment{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Fragment{T})\n\nCreates a copy of the given fragment in the given chain. The new fragment is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Nucleotides","page":"System representation","title":"Nucleotides","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Nucleotide\nNucleotideTable\nnnucleotides\nnucleotide_by_idx\nnucleotides\nparent_nucleotide\nBase.push!(::Chain{T}, ::Nucleotide{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Nucleotide","page":"System representation","title":"BiochemicalAlgorithms.Nucleotide","text":"Nucleotide{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual nucleotide in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nNucleotide(\n    chain::Chain{T},\n    number::Int;\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Nucleotide{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.NucleotideTable","page":"System representation","title":"BiochemicalAlgorithms.NucleotideTable","text":"NucleotideTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system nucleotides (or a subset thereof). Nucleotide tables can be generated using nucleotides or filtered from other nucleotide tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.nnucleotides","page":"System representation","title":"BiochemicalAlgorithms.nnucleotides","text":"nnucleotides(::Chain)\nnnucleotides(::Molecule)\nnnucleotides(::System)\n\nReturns the number of nucleotides in the given atom container.\n\nSupported keyword arguments\n\nSee nucleotides\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nucleotide_by_idx","page":"System representation","title":"BiochemicalAlgorithms.nucleotide_by_idx","text":"nucleotide_by_idx(sys::System{T}, idx::Int64) -> Nucleotide\n\n\nReturns the Nucleotide{T} associated with the given idx in sys. Throws a KeyError if no such nucleotide exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nucleotides","page":"System representation","title":"BiochemicalAlgorithms.nucleotides","text":"nucleotides(::Chain)\nnucleotides(::Molecule)\nnucleotides(::System)\n\nReturns a NucleotideTable{T} containing all nucleotides of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to nucleotides matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_nucleotide","page":"System representation","title":"BiochemicalAlgorithms.parent_nucleotide","text":"parent_nucleotide(::Atom)\n\nReturns the Nucleotide{T} containing the given atom. Returns nothing if no such nucleotide exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Nucleotide{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Nucleotide{T})\n\nCreates a copy of the given nucleotide in the given chain. The new nucleotide is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Residues","page":"System representation","title":"Residues","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Residue\nResidueTable\nnresidues\nparent_residue\nresidue_by_idx\nresidues\nBase.push!(::Chain{T}, ::Residue{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Residue","page":"System representation","title":"BiochemicalAlgorithms.Residue","text":"Residue{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual residue in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\ntype::AminoAcid\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nResidue(\n    chain::Chain{T},\n    number::Int,\n    type::AminoAcid;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Residue{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.ResidueTable","page":"System representation","title":"BiochemicalAlgorithms.ResidueTable","text":"ResidueTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system residues (or a subset thereof). Residue tables can be generated using residues or filtered from other residue tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\ntype::AbstractVector{AminoAcid}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.nresidues","page":"System representation","title":"BiochemicalAlgorithms.nresidues","text":"nresidues(::Chain)\nnresidues(::Molecule)\nnresidues(::System)\n\nReturns the number of residues in the given atom container.\n\nSupported keyword arguments\n\nSee residues\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_residue","page":"System representation","title":"BiochemicalAlgorithms.parent_residue","text":"parent_residue(::Atom)\n\nReturns the Residue{T} containing the given atom. Returns nothing if no such residue exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.residue_by_idx","page":"System representation","title":"BiochemicalAlgorithms.residue_by_idx","text":"residue_by_idx(sys::System{T}, idx::Int64) -> Residue\n\n\nReturns the Residue{T} associated with the given idx in sys. Throws a KeyError if no such residue exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.residues","page":"System representation","title":"BiochemicalAlgorithms.residues","text":"residues(::Chain)\nresidues(::Molecule)\nresidues(::System)\n\nReturns a ResidueTable{T} containing all residues of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to residues matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Residue{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Residue{T})\n\nCreates a copy of the given residue in the given chain. The new residue is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/read_and_write/#All-on-Input-and-Output","page":"read and write","title":"All on Input and Output","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"BiochemicalAlgorithms.jl supports the reading and writing of several common structural data formats.","category":"page"},{"location":"tutorials/read_and_write/#Protein-Data-Bank-Format-(PDB)","page":"read and write","title":"Protein Data Bank Format (PDB)","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"The most common format ist the PDB. Have a look at Learning about PDB data if you want to refresh your knowledge about this format. For a deeper understanding you can also read PDB format specifications.","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"Read a PDB file from the BiochemicalAlgorithms.jl repository:","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"System with 23 atoms (AlaAla.pdb)","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"Write the same system back into a new PDB file:","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"# \nwrite_pdb(\"Ala_out.pdb\", sys)","category":"page"},{"location":"tutorials/read_and_write/#PubChem","page":"read and write","title":"PubChem","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"In addition to PDB, the pubchem data base plays an important role as a source of structural data. Pubchem allows to retrieve data in JSON which is read by BiochemicalAlgorithms.jl as shown below:","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"sys = load_pubchem_json(ball_data_path(\"../test/data/aspirin_pug.json\"))","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"System with 21 atoms","category":"page"},{"location":"tutorials/read_and_write/#SD-file","page":"read and write","title":"SD file","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"sys = load_sdfile(ball_data_path(\"../test/data/rings_test.sdf\"))","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"System with 148 atoms (rings_test.sdf)","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"Write the system into a new SD file:","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"write_sdfile(\"rings_test_out.sdf\", sys)","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"┌ Warning: write_sdfile: writer only supports 2D data; projecting atoms onto xy-plane...\n└ @ BiochemicalAlgorithms ~/git/ball.jl/src/fileformats/sdfile.jl:23\n[ Info: 9 records exported.","category":"page"},{"location":"CONTRIBUTING/#Contributing-Guidelines","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"","category":"section"},{"location":"CONTRIBUTING/#Certificate-of-Origin","page":"Contributing Guidelines","title":"Certificate of Origin","text":"","category":"section"},{"location":"CONTRIBUTING/","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"Source: Developer Certificate of Origin","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"All contributions to this project need to be in agreement with the Developer Certificate of Origin. In particular, all commits contributed to this repository need to include the following line in their respective commit message to certify agreement, with name and e-mail address modified accordingly:","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"Signed-off-by: Name <E-mail>","category":"page"},{"location":"CONTRIBUTING/","page":"Contributing Guidelines","title":"Contributing Guidelines","text":"You can use the --signoff (or -s) option of the git commit command to facilitate this process.","category":"page"},{"location":"private/mappings/#Mappings","page":"Mappings","title":"Mappings","text":"","category":"section"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"Pages = [\"mappings.md\"]","category":"page"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"_compute_rotation","category":"page"},{"location":"private/mappings/#BiochemicalAlgorithms._compute_rotation","page":"Mappings","title":"BiochemicalAlgorithms._compute_rotation","text":"_compute_rotation(\n    R::StaticArraysCore.SArray{Tuple{3, 3}, T<:Real, 2},\n    _::Type{RMSDMinimizerKabsch}\n) -> Any\n\n\nComputes the rotation matrix by solving the eigen value problem given as the correlation matrix C. Uses all resulting eigenvalues and eigenvectors. Warns if the correlation matrix is not positive definit (contains negative eigenvalues or eigenvalues equal to 0) and uses the alternative approch RMSDMinimizerCoutsias instead. Returns a RotMatrix3.\n\n\n\n\n\n_compute_rotation(\n    R::StaticArraysCore.SArray{Tuple{3, 3}, T<:Real, 2},\n    _::Type{RMSDMinimizerCoutsias}\n) -> Rotations.RotMatrix3{T} where T<:Real\n\n\nComputes the rotation matrix by solving the eigen value problem given as the residual matrix F. Uses only the largest of the resulting eigenvalues to generate the Quaternion describing the  optimal rotation that maps the atoms onto each other. Returns a RotMatrix3.\n\n\n\n\n\n","category":"function"},{"location":"private/system/#Model","page":"System representation","title":"Model","text":"","category":"section"},{"location":"private/system/","page":"System representation","title":"System representation","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"private/system/","page":"System representation","title":"System representation","text":"Pages = [\"system.md\"]","category":"page"},{"location":"private/system/","page":"System representation","title":"System representation","text":"_default_system\n_next_idx","category":"page"},{"location":"private/system/#BiochemicalAlgorithms._default_system","page":"System representation","title":"BiochemicalAlgorithms._default_system","text":"const _default_system\n\nGlobal default system.\n\n\n\n\n\n","category":"constant"},{"location":"private/system/#BiochemicalAlgorithms._next_idx","page":"System representation","title":"BiochemicalAlgorithms._next_idx","text":"_next_idx(sys::System{T}) -> Int64\n\n\nReturns the next available idx for the given system.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/iterate/#All-on-iteration","page":"iterate","title":"All on iteration","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"When working with molecular entities, we want to run over all atoms of a system, over all chains, etc. In this tutorial we will learn how this can be done.","category":"page"},{"location":"tutorials/iterate/#Molecular-systems","page":"iterate","title":"Molecular systems","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"In BiochemicalAlgorithms.jl atoms and bonds are existing inside a System. Typically, molecular data is stored in molecular data formats such as PDB. The latter can be directly read into a system.","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"System with 23 atoms (AlaAla.pdb)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"You can, e.g., print all atoms of the given system as a table:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"atoms(sys)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# idx number element name atom_type r v F formal_charge charge radius\n1 5 1 N N  Float32[-1.45, 0.0, 0.0] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n2 6 2 C CA  Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n3 7 3 C C  Float32[0.495, 0.0, 1.437] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n4 8 4 O O  Float32[1.235, -0.911, 1.838] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n5 9 5 H 1H  Float32[-1.788, 0.918, 0.25] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n6 10 6 H 1HB  Float32[1.642, 1.124, -0.864] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n7 11 7 H 2H  Float32[-1.801, -0.26, -0.911] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n8 12 8 H 2HB  Float32[0.154, 1.136, -1.827] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n9 13 9 H 3H  Float32[-1.749, -0.665, 0.704] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n10 14 10 H 3HB  Float32[0.258, 2.118, -0.351] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n11 15 11 C CB  Float32[0.554, 1.175, -0.813] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n12 16 12 H HA  Float32[0.341, -0.928, -0.46] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n13 17 13 N N  Float32[0.133, 0.98, 2.268] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n14 18 14 C CA  Float32[0.605, 0.98, 3.639] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n15 19 15 C C  Float32[0.414, -0.408, 4.228] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n16 20 16 H H  Float32[-0.476, 1.73, 1.938] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n17 21 17 H 1HB  Float32[0.325, 2.106, 5.472] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n18 22 18 H 2HB  Float32[0.065, 3.039, 3.988] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n19 23 19 H 3HB  Float32[-1.16, 1.868, 4.519] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n20 24 20 C CB  Float32[-0.089, 2.07, 4.463] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n21 25 21 H HA  Float32[1.676, 1.185, 3.63] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n22 26 22 O O  Float32[0.531, -1.358, 3.421] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n23 27 23 O OXT  Float32[0.462, -0.512, 5.473] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"AtomTable{Float32} with 23 rows:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Single columns can be directly accessed by their name:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"atoms(sys).name","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"23-element BiochemicalAlgorithms._RowProjectionVector{String}:\n \"N\"\n \"CA\"\n \"C\"\n \"O\"\n \"1H\"\n \"1HB\"\n \"2H\"\n \"2HB\"\n \"3H\"\n \"3HB\"\n \"CB\"\n \"HA\"\n \"N\"\n \"CA\"\n \"C\"\n \"H\"\n \"1HB\"\n \"2HB\"\n \"3HB\"\n \"CB\"\n \"HA\"\n \"O\"\n \"OXT\"","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"You can also directly query the number of atoms via natoms:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"natoms(sys)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"23","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Similar functions exist for other system components, including bonds, molecules, chains, and fragments.","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-atoms-of-a-system?","page":"iterate","title":"How can I iterate over all atoms of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"We can just as easily iterate over all atoms:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"for atom in atoms(sys)\n    # do something with this atom\nend","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Or, for individual columns:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"for atom_name in atoms(sys).name\n    # do something with this atom name\nend","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-specific-atoms?","page":"iterate","title":"How can I iterate over specific atoms?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"In many scenarios, we only want to iterate over a subset of atoms fulfilling a specific criteria. For example, here we only want to get the positions of the C_alpha atoms:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"ca_atoms = filter(atom -> atom.name == \"CA\", atoms(sys))","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# idx number element name atom_type r v F formal_charge charge radius\n1 6 2 C CA  Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n2 18 14 C CA  Float32[0.605, 0.98, 3.639] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"AtomTable{Float32} with 2 rows:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"And here we only want the heavy atoms:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"heavy_atoms = filter(atom -> atom.element != Elements.H, atoms(sys))","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# idx number element name atom_type r v F formal_charge charge radius\n1 5 1 N N  Float32[-1.45, 0.0, 0.0] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n2 6 2 C CA  Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n3 7 3 C C  Float32[0.495, 0.0, 1.437] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n4 8 4 O O  Float32[1.235, -0.911, 1.838] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n5 15 11 C CB  Float32[0.554, 1.175, -0.813] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n6 17 13 N N  Float32[0.133, 0.98, 2.268] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n7 18 14 C CA  Float32[0.605, 0.98, 3.639] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n8 19 15 C C  Float32[0.414, -0.408, 4.228] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n9 24 20 C CB  Float32[-0.089, 2.07, 4.463] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n10 26 22 O O  Float32[0.531, -1.358, 3.421] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0\n11 27 23 O OXT  Float32[0.462, -0.512, 5.473] Float32[0.0, 0.0, 0.0] Float32[0.0, 0.0, 0.0] 0 0.0 0.0","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"AtomTable{Float32} with 11 rows:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Instead of a system, we can use any other system component as an argument to the atoms function to only list the atoms of the same component. For example, the following system contains two chains:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"sys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\nchains(sys)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# idx name\n1 2 E\n2 349 I","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"ChainTable{Float32} with 2 rows:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"In order to get all atoms of the first chain, we can use:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"chainE = first(chains(sys))\nfor atom in atoms(chainE)\n    # do something with this atom of the first chain\nend","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"We can even combine this approach with filtering to get, e.g., only the C_alpha atoms of the first chain:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"for atom in filter(atom -> atom.name == \"CA\", atoms(chainE))\n    # do something with this CA atom of the first chain\nend","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-bonds-of-a-system?","page":"iterate","title":"How can I iterate over all bonds of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Bonds are not explicitely stored in the pdb-Format but are rather inferred after reading the data into a system using the fragment database FragmentDB:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\n\n# bonds are not contained in the pdb file\nnbonds(sys)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"0","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# use the fragment database for normalizing naming schemas between molecular file formats, reconstruction of missing parts of the structure and building the bonds\nfdb = FragmentDB()\n\nnormalize_names!(sys, fdb)\nreconstruct_fragments!(sys, fdb)\nbuild_bonds!(sys, fdb)\n\nnbonds(sys)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"[ Info: reconstruct_fragments!(): added 0 atoms.\n[ Info: build_bonds!(): built 22 bonds\n\n22","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Similar to the atom iteration, we can iterate over all bonds of a sysem:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"for bond in bonds(sys)\n    # do something with this bond\nend","category":"page"},{"location":"tutorials/handle_molecules/#All-on-Handling-molecules","page":"handle molecules","title":"All on Handling molecules","text":"","category":"section"},{"location":"tutorials/handle_molecules/#How-can-I-create-a-simple-molecule?","page":"handle molecules","title":"How can I create a simple molecule?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"# create a system first\nsys = System{Float32}() # this system will be of single precision, i.e., atom positions, velocities... \n\n# as well as a molecule\nh2o = Molecule(sys)\n\n# create system atoms\no1 = Atom(h2o, 1, Elements.O)\nh1 = Atom(h2o, 2, Elements.H)\nh2 = Atom(h2o, 3, Elements.H)\n\n# set positions of the atoms\n# o1.r = [0, 0, 0]  <-- this is the default value!\nh1.r = [1, 0, 0]\nh2.r = [cos(deg2rad(105)), sin(deg2rad(105)), 0]\n\n# add bonds\nBond(h2o, o1.idx, h1.idx, BondOrder.Single)\nBond(h2o, o1.idx, h2.idx, BondOrder.Single)\n\nprintln(\"Number of atoms: \", natoms(h2o))\nprintln(\"Number of bonds: \", nbonds(h2o))","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"Number of atoms: 3\nNumber of bonds: 2","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-determine-the-element-type-of-an-atom-(C,-N,-…)?","page":"handle molecules","title":"How can I determine the element type of an atom (C, N, …)?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"The element of an atom is represented by elements.jl:","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\nfor atom in atoms(sys)\n    println(\"Atom no.: $(atom.number), element: $(atom.element)\")\nend","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"Atom no.: 1, element: N\nAtom no.: 2, element: C\nAtom no.: 3, element: C\nAtom no.: 4, element: O\nAtom no.: 5, element: H\nAtom no.: 6, element: H\nAtom no.: 7, element: H\nAtom no.: 8, element: H\nAtom no.: 9, element: H\nAtom no.: 10, element: H\nAtom no.: 11, element: C\nAtom no.: 12, element: H\nAtom no.: 13, element: N\nAtom no.: 14, element: C\nAtom no.: 15, element: C\nAtom no.: 16, element: H\nAtom no.: 17, element: H\nAtom no.: 18, element: H\nAtom no.: 19, element: H\nAtom no.: 20, element: C\nAtom no.: 21, element: H\nAtom no.: 22, element: O\nAtom no.: 23, element: O","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"You can also filter for specific elements:","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"c_atoms = filter(atom -> atom.element == Elements.C, atoms(sys))\nfor atom in c_atoms\n    println(\"Atom no.: $(atom.number), element: $(atom.element)\")\nend","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"Atom no.: 2, element: C\nAtom no.: 3, element: C\nAtom no.: 11, element: C\nAtom no.: 14, element: C\nAtom no.: 15, element: C\nAtom no.: 20, element: C","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-identify-backbone-atoms?","page":"handle molecules","title":"How can I identify backbone atoms?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\nfor atom in atoms(sys)\n    print(atom.element)\n    if atom.name in [\"C\", \"O\", \"N\", \"HA\"]\n        print(\" <-- This is a backbone atom!\")\n    end\n    println()\nend","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"N <-- This is a backbone atom!\nC\nC <-- This is a backbone atom!\nO <-- This is a backbone atom!\nH\nH\nH\nH\nH\nH\nC\nH <-- This is a backbone atom!\nN <-- This is a backbone atom!\nC\nC <-- This is a backbone atom!\nH\nH\nH\nH\nC\nH <-- This is a backbone atom!\nO <-- This is a backbone atom!\nO","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-get-the-one-letter-code-out-of-a-pdb-file?","page":"handle molecules","title":"How can I get the one-letter code out of a pdb file?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"sys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\nfor chain in chains(sys)\n    # get all residues from the current chain\n    res = [res.name for res in fragments(chain) if is_amino_acid(res.name)]\n    println(\"> Chain $(chain.name)\")\n    println(join(one_letter_code.(res), \"\"))\nend","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"> Chain E\nIVGGYTCGANTVPYQVSLNSGYHFCGGSLINSQWVVSAAHCYKSGIQVRLGEDNINVVEGNEQFISASKSIVHPSYNSNTLNNDIMLIKLKSAASLNSRVASISLPTSCASAGTQCLISGWGNTKSSGTSYPDVLKCLKAPILSDSSCKSAYPGQITSNMFCAYGLEGKGDSCQGDSGGPVVCSGKLQGIVSWGSGCQAKNKPGVYTKVCNYVSWIKQTIASN\n> Chain I\nRPDFCLEPPYTGPCKARIIRYFYNAKAGLCQTFVYGGCRAKRNNFKSAEDCMRTCGGA","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-pick-one-single-chain-out-of-a-system-containing-several-chains?","page":"handle molecules","title":"How can I pick one single chain out of a system containing several chains?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"This is often needed when a receptor and a ligand are co-complexed and you want to treat them separately.","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"sys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\n\nall_chains = chains(sys)","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"# idx name\n1 2 E\n2 349 I","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"ChainTable{Float32} with 2 rows:","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"This snippet will create separate PDB files for the two chains of the system:","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"write_pdb(\"2ptc_chainE.pdb\", all_chains[1])\nwrite_pdb(\"2ptc_chainI.pdb\", all_chains[2])","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-map-two-configurations-of-the-same-protein-onto-each-other?","page":"handle molecules","title":"How can I map two configurations of the same protein onto each other?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"# read in the first protein\nsys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\nmol = first(molecules(sys))\n\n# we will generate a second version of the protein by moving it around\nsys2 = deepcopy(sys)\nmol2 = first(molecules(sys2))\ntranslate!(mol2, Vector3{Float32}(2.0,1.0,2.0))\n\n# let's see how far the structures are apart\nprintln(\"RMSD before mapping:\\t\", compute_rmsd(mol2, mol))\n\n# now we have two proteins or system we can map together\nmap_rigid!(mol2, mol)\n\n# let's see how far the structures are apart afterwards\nprintln(\"RMSD after mapping:\\t\", compute_rmsd(mol2, mol))","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"RMSD before mapping:    3.0\nRMSD after mapping: 1.8518733e-5","category":"page"},{"location":"tutorials/getting_started/#Welcome-to-BiochemicalAlgorithms.jl","page":"get started","title":"Welcome to BiochemicalAlgorithms.jl","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"In this tutorial, you will learn about the basic concepts of the BiochemicalAlgorithms.jl library, a complete rewrite of the C++ framework BALL in Julia.","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"To use BiochemicalAlgorithms.jl in your code, add it to your project","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"using Pkg\nPkg.add(\"BiochemicalAlgorithms\")","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"and use it in your code:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"using BiochemicalAlgorithms","category":"page"},{"location":"tutorials/getting_started/#Representing-molecular-systems","page":"get started","title":"Representing molecular systems","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"In BiochemicalAlgorithms.jl, all molecules are stored in so-called Systems. While a System can be created from scratch and filled programmatically, it is commonly created by reading a molecular file, such as a PDB-file:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"s = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"System with 2241 atoms (2ptc.pdb)","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"You can then run methods on this system, e.g.","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"println(\"The system $(s.name) contains $(natoms(s)) atoms.\")","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"The system 2ptc.pdb contains 2241 atoms.","category":"page"},{"location":"tutorials/getting_started/#Common-preparation-steps","page":"get started","title":"Common preparation steps","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"The data stored in many molecular file formats is incomplete, or needs to be normalized in certain ways. PDB-files, for instance, often omit hydrogen atoms, and don’t usually store bonds that can be inferred otherwise. BiochemicalAlgorithms.jl offers a number of methods that perform preparation steps that are common to most molecular modelling applications, such as normalizing atom- and fragment names, computing bonds, adding missing atoms from a library of templates (such as amino acids), or saturating a molecule with hydrogen atoms. The template information used by these methods is stored in the so-called FragmentDB. A common series of operations to prepare a system for further processing is as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"fdb = FragmentDB()\nnormalize_names!(s, fdb)\nreconstruct_fragments!(s, fdb)\nbuild_bonds!(s, fdb)","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"┌ Warning: reconstruct_fragments!(): could not find reference fragment for  CA:462\n└ @ BiochemicalAlgorithms ~/git/ball.jl/src/preprocessing/reconstruct_fragments.jl:177\n[ Info: reconstruct_fragments!(): added 2364 atoms.\n┌ Warning: build_bonds!(): could not find reference fragment for  CA.\n└ @ BiochemicalAlgorithms ~/git/ball.jl/src/preprocessing/build_bonds.jl:14\n[ Info: build_bonds!(): built 4498 bonds","category":"page"},{"location":"#BiochemicalAlgorithms","page":"Home","title":"BiochemicalAlgorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"BiochemicalAlgorithms.jl is a redesign of the popular Biochemical Algorithms Library (BALL), the largest open source C++-framework of its kind. We focused on three main design goals: efficiency, ease of use and rapid application development (RAD). Our library provides functionality for file I/O, molecular modelling, molecular mechanics methods, and molecular visualization, and hence can serve as a foundation for developing applications within the Julia ecosystem.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install BiochemicalAlgorithms, open a Julia REPL, switch to the package mode by pressing ], and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add BiochemicalAlgorithms","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple impression of what you can do with BiochemicalAlgorithms.jl.  Central to every application is a System, which is filled with structures by reading in atom coordinates from PDB or PubChem JSON files. The system is preprocessed by the FragementDB performing three steps: name normalization, reconstruction of missing atoms, and the construction of atomic bonds. The energy of the structure is evaluated using Amber forcefield.  With the help of BiochemicalVisualization.jl the structure can be visualized as a ball-and-stick model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BiochemicalAlgorithms\n\n# Read PDB file from the BiochemicalAlgorithms.jl repository\nsys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\n\nprintln(\"Number of atoms: \", natoms(sys))\nprintln(\"Number of bonds: \", nbonds(sys))\n\n# Prepare molecule\nfdb = FragmentDB()\nnormalize_names!(sys, fdb)\nreconstruct_fragments!(sys, fdb)\nbuild_bonds!(sys, fdb)\nprintln(\"Number of bonds: \", nbonds(sys))\n\n# Create Amber force field and compute the energy of the system\namber = AmberFF(sys)\ncompute_energy(amber)\nprintln(amber.energy)","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If the previous section whetted your appetite, have a look at our tutorials to get started.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You have ideas for improvements, criticism, or ran into problems?  You are looking for a feature that you know from BALL?  Feedback and contributions are very welcome. Check out our guidelines and use our issue tracker or contact us via e-mail.","category":"page"}]
}
