var documenterSearchIndex = {"docs":
[{"location":"public/system/#System-representation","page":"System representation","title":"System representation","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Pages = [\"system.md\"]","category":"page"},{"location":"public/system/#Abstract-types","page":"System representation","title":"Abstract types","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"AbstractColumnTable\nAbstractSystemComponentTable\nAbstractSystemComponent\nAbstractAtomContainer","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.AbstractColumnTable","page":"System representation","title":"BiochemicalAlgorithms.AbstractColumnTable","text":"abstract type AbstractColumnTable <: Tables.AbstractColumns\n\nAbstract base type for all Tables.jl-compatible column tables.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractSystemComponentTable","page":"System representation","title":"BiochemicalAlgorithms.AbstractSystemComponentTable","text":"abstract type AbstractSystemComponentTable{T<:Real} <: AbstractColumnTable\n\nAbstract base type for all Tables.jl-compatible system component tables.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractSystemComponent","page":"System representation","title":"BiochemicalAlgorithms.AbstractSystemComponent","text":"abstract type AbstractSystemComponent{T<:Real}\n\nAbstract base type for all components of a system, including the system itself.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AbstractAtomContainer","page":"System representation","title":"BiochemicalAlgorithms.AbstractAtomContainer","text":"abstract type AbstractAtomContainer{T} <: AbstractSystemComponent{T}\n\nAbstract base type for all atom containers.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#Common-functions","page":"System representation","title":"Common functions","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"has_property\nget_property\nset_property!\nhas_flag\nset_flag!\nunset_flag!","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.has_property","page":"System representation","title":"BiochemicalAlgorithms.has_property","text":"has_property(\n    ac::AbstractSystemComponent,\n    key::Symbol\n) -> Any\n\n\nReturns a Bool indicating whether the given system component has the given property.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.get_property","page":"System representation","title":"BiochemicalAlgorithms.get_property","text":"get_property(\n    ac::AbstractSystemComponent,\n    key::Symbol\n) -> Any\n\n\nReturns the property associated with the given key in ac.\n\n\n\n\n\nget_property(\n    ac::AbstractSystemComponent,\n    key::Symbol,\n    default\n) -> Any\n\n\nReturns the property associated with the given key in ac. If no such property exists, returns default.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.set_property!","page":"System representation","title":"BiochemicalAlgorithms.set_property!","text":"set_property!(\n    ac::AbstractSystemComponent,\n    key::Symbol,\n    value\n) -> Any\n\n\nSets the property associated with the given key in ac to the given value.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.has_flag","page":"System representation","title":"BiochemicalAlgorithms.has_flag","text":"has_flag(ac::AbstractSystemComponent, flag::Symbol) -> Any\n\n\nReturns a Bool indicating whether the given system component has the given flag.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.set_flag!","page":"System representation","title":"BiochemicalAlgorithms.set_flag!","text":"set_flag!(ac::AbstractSystemComponent, flag::Symbol) -> Any\n\n\nAdds the given flag to ac.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.unset_flag!","page":"System representation","title":"BiochemicalAlgorithms.unset_flag!","text":"unset_flag!(\n    ac::AbstractSystemComponent,\n    flag::Symbol\n) -> Any\n\n\nRemoves the given flag from ac.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Systems","page":"System representation","title":"Systems","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"System\ndefault_system\nBase.parent(::System)\nparent_system","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.System","page":"System representation","title":"BiochemicalAlgorithms.System","text":"mutable struct System{T} <: AbstractAtomContainer{T}\n\nMutable representation of a biomolecular system.\n\nFields\n\nname::String\nproperties::Properties\nflags::Flags\n\nConstructors\n\nSystem(name::String = \"\", properties::Properties = Properties(), flags::Flags = Flags())\n\nCreates a new and empty System{Float32}.\n\nSystem{T}(name::String = \"\", properties::Properties = Properties(), flags::Flags = Flags())\n\nCreates a new and empty System{T}.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.default_system","page":"System representation","title":"BiochemicalAlgorithms.default_system","text":"default_system() -> System{Float32}\n\n\nReturns the global default system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.parent-Tuple{System}","page":"System representation","title":"Base.parent","text":"parent(::Atom)\nparent(::Bond)\nparent(::Chain)\nparent(::Fragment)\nparent(::Molecule)\nparent(::Nucleotide)\nparent(::Residue)\nparent(::System)\n\nReturns the System{T} containing the given object.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#BiochemicalAlgorithms.parent_system","page":"System representation","title":"BiochemicalAlgorithms.parent_system","text":"parent_system(::Atom)\nparent_system(::Bond)\nparent_system(::Chain)\nparent_system(::Fragment)\nparent_system(::Molecule)\nparent_system(::Nucleotide)\nparent_system(::Residue)\nparent_system(::System)\n\nReturns the System{T} containing the given object. Alias for  Base.parent.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Atoms","page":"System representation","title":"Atoms","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Atom\nAtomTable\natom_by_idx\natom_by_name\natoms\nis_bound_to\nis_geminal\nis_vicinal\nnatoms\nBase.push!(::System{T}, ::Atom{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Atom","page":"System representation","title":"BiochemicalAlgorithms.Atom","text":"Atom{T} <: AbstractSystemComponent{T}\n\nMutable representation of an individual atom in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nelement::ElementType\nname::String\natom_type::String\nr::Vector3{T}\nv::Vector3{T}\nF::Vector3{T}\nformal_charge::Int\ncharge::T\nradius::T\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nframe_id::Int\nmolecule_idx::MaybeInt\nchain_idx::MaybeInt\nfragment_idx::MaybeInt\nnucleotide_idx::MaybeInt\nresidue_idx::MaybeInt\n\nConstructors\n\nAtom(\n    ac::AbstractAtomContainer{T}\n    number::Int,\n    element::ElementType;\n    # keyword arguments\n    name::String = \"\",\n    atom_type::String = \"\",\n    r::Vector3{T} = Vector3{T}(0, 0, 0),\n    v::Vector3{T} = Vector3{T}(0, 0, 0),\n    F::Vector3{T} = Vector3{T}(0, 0, 0),\n    formal_charge::Int = 0,\n    charge::T = zero(T),\n    radius::T = zero(T),\n    properties::Properties = Properties(),\n    flags::Flags = Flags(),\n    frame_id::Int = 1\n    molecule_idx::MaybeInt = nothing,\n    chain_idx::MaybeInt = nothing,\n    fragment_idx::MaybeInt = nothing,\n    nucleotide_idx::MaybeInt = nothing,\n    residue_idx::MaybeInt = nothing\n)\n\nCreates a new Atom{T} in the given atom container.\n\nAtom(\n    number::Int,\n    element::ElementType;\n    kwargs...\n)\n\nCreates a new Atom{Float32} in the default system. Supports the same keyword arguments as above.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.AtomTable","page":"System representation","title":"BiochemicalAlgorithms.AtomTable","text":"AtomTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system atoms (or a subset thereof). Atom tables can be generated using atoms or filtered from other atom tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nelement::AbstractVector{ElementType}\nname::AbstractVector{String}\natom_type::AbstractVector{String}\nr::AbstractVector{Vector3{T}}\nv::AbstractVector{Vector3{T}}\nF::AbstractVector{Vector3{T}}\nformal_charge::AbstractVector{Int}\ncharge::AbstractVector{T}\nradius::AbstractVector{T}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nframe_id::AbstractVector{Int}\nmolecule_idx::AbstractVector{MaybeInt}\nchain_idx::AbstractVector{MaybeInt}\nfragment_idx::AbstractVector{MaybeInt}\nnucleotide_idx::AbstractVector{MaybeInt}\nresidue_idx::AbstractVector{MaybeInt}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.atom_by_idx","page":"System representation","title":"BiochemicalAlgorithms.atom_by_idx","text":"atom_by_idx(sys::System{T}, idx::Int64) -> Atom\n\n\nReturns the Atom{T} associated with the given idx in sys. Throws a KeyError if no such atom exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.atom_by_name","page":"System representation","title":"BiochemicalAlgorithms.atom_by_name","text":"atom_by_name(\n    ac::AbstractAtomContainer{T},\n    name::String;\n    frame_id\n) -> Union{Nothing, Atom}\n\n\nReturns the first Atom{T} associated with the given name in ac. Returns nothing if no such atom exists.\n\nSupported keyword arguments\n\nframe_id::MaybeInt = 1: Any value other than nothing limits the result to atoms matching this frame ID.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.atoms","page":"System representation","title":"BiochemicalAlgorithms.atoms","text":"atoms(::Chain)\natoms(::Fragment)\natoms(::Molecule)\natoms(::Nucleotide)\natoms(::Residue)\natoms(::System)\n\nReturns an AtomTable{T} containing all atoms of the given atom container.\n\nSupported keyword arguments\n\nframe_id::MaybeInt = 1\nmolecule_idx::Union{MaybeInt, Some{Nothing}} = nothing\nchain_idx::Union{MaybeInt, Some{Nothing}} = nothing\nfragment_idx::Union{MaybeInt, Some{Nothing}} = nothing\nnucleotide_idx::Union{MaybeInt, Some{Nothing}} = nothing\nresidue_idx::Union{MaybeInt, Some{Nothing}} = nothing\n\nAll keyword arguments limit the results to atoms matching the given IDs. Keyword arguments set to nothing are ignored. You can use Some(nothing) to explicitly filter for ID values of nothing.\n\n\n\n\n\natoms(\n    substruct::Substructure{T, A} where A<:AbstractAtomContainer{T};\n    frame_id,\n    molecule_idx,\n    chain_idx,\n    fragment_idx,\n    nucleotide_idx,\n    residue_idx\n) -> SystemComponentTable{T, C} where {T, C<:Atom{T}}\n\n\nReturns an AtomTable for all of the given system's atoms matching the given criteria (value or missing). Fields given as nothing are ignored. The returned table contains all public and private atom fields.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_bound_to","page":"System representation","title":"BiochemicalAlgorithms.is_bound_to","text":"is_bound_to(a1::Atom, a2::Atom) -> Bool\n\n\nDecides if two atoms are bound to each other. Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_geminal","page":"System representation","title":"BiochemicalAlgorithms.is_geminal","text":"is_geminal(a1::Atom, a2::Atom) -> Union{Missing, Bool}\n\n\nDecides if two atoms are geminal.\n\nTwo atoms are geminal if they do not share a common bond but both have a bond to a third atom. For example the two hydrogen atoms in water are geminal.  Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.is_vicinal","page":"System representation","title":"BiochemicalAlgorithms.is_vicinal","text":"is_vicinal(a1::Atom, a2::Atom) -> Bool\n\n\nDecides if two atoms are vicinal.\n\nTwo atoms are vicinal if they are separated by three bonds (1-4 position). Hydrogen bonds (has_flag(bond, :TYPE__HYDROGEN)) are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.natoms","page":"System representation","title":"BiochemicalAlgorithms.natoms","text":"natoms(::Chain)\nnatoms(::Fragment)\nnatoms(::Molecule)\nnatoms(::Nucleotide)\nnatoms(::Residue)\nnatoms(::System)\n\nReturns the number of atoms in the given atom container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Atom{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Fragment{T},   ::Atom{T})\npush!(::Molecule{T},   ::Atom{T})\npush!(::Nucleotide{T}, ::Atom{T})\npush!(::Residue{T},    ::Atom{T})\npush!(::System{T},     ::Atom{T})\n\nCreates a copy of the given atom in the given atom container. The new atom is automatically assigned a new idx.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Bonds","page":"System representation","title":"Bonds","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Bond\nBondTable\nbond_by_idx\nbonds\nnbonds\nBase.push!(::System{T}, ::Bond{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Bond","page":"System representation","title":"BiochemicalAlgorithms.Bond","text":"Bond{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual bond in a system.\n\nPublic fields\n\nidx::Int\na1::Int\na2::Int\norder::BondOrderType\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\n\nConstructors\n\nBond(\n    sys::System{T}, \n    a1::Int, \n    a2::Int, \n    order::BondOrderType;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Bond{T} in the given system.\n\nBond(\n    a1::Int,\n    a2::Int,\n    order::BondOrderType;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Bond{Float32} in the default system.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.BondTable","page":"System representation","title":"BiochemicalAlgorithms.BondTable","text":"BondTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system bonds (or a subset thereof). Bond tables can be generated using bonds or filtered from other bond tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\na1::AbstractVector{Int}\na2::AbstractVector{Int}\norder::AbstractVector{BondOrderType}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.bond_by_idx","page":"System representation","title":"BiochemicalAlgorithms.bond_by_idx","text":"bond_by_idx(sys::System{T}, idx::Int64) -> Bond\n\n\nReturns the Bond{T} associated with the given idx in sys. Throws a KeyError if no such bond exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.bonds","page":"System representation","title":"BiochemicalAlgorithms.bonds","text":"bonds(::Chain)\nbonds(::Fragment)\nbonds(::Molecule)\nbonds(::Nucleotide)\nbonds(::Residue)\nbonds(::System)\n\nReturns a BondTable{T} containing all bonds of the given atom container where at least one associated atom is contained in the same container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\nbonds(::Atom)\n\nReturns a BondTable{T} containing all bonds of the given atom.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nbonds","page":"System representation","title":"BiochemicalAlgorithms.nbonds","text":"nbonds(::Chain)\nnbonds(::Fragment)\nnbonds(::Molecule)\nnbonds(::Nucleotide)\nnbonds(::Residue)\nnbonds(::System)\n\nReturns the number of bonds in the given atom container where at least one associated atom is contained in the same container.\n\nSupported keyword arguments\n\nSee atoms\n\n\n\n\n\nnbonds(::Atom)\n\nReturns the number of bonds of the given atom.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Bond{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::AbstractAtomContainer, ::Bond{T})\n\nCreates a copy of the given bond in the system associated with the given atom container. The new bond is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Molecules","page":"System representation","title":"Molecules","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Molecule\nMoleculeTable\nmolecule_by_idx\nmolecules\nnmolecules\nparent_molecule\nBase.push!(::System{T}, ::Molecule{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Molecule","page":"System representation","title":"BiochemicalAlgorithms.Molecule","text":"Molecule{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual molecule in a system.\n\nPublic fields\n\nidx::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\n\nConstructors\n\nMolecule(\n    sys::System{T};\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Molecule{T} in the given system.\n\nMolecule(;\n    #keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Molecule{Float32} in the default system.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.MoleculeTable","page":"System representation","title":"BiochemicalAlgorithms.MoleculeTable","text":"MoleculeTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system molecules (or a subset thereof). Molecule tables can be generated using molecules or filtered from other molecule tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.molecule_by_idx","page":"System representation","title":"BiochemicalAlgorithms.molecule_by_idx","text":"molecule_by_idx(sys::System{T}, idx::Int64) -> Molecule\n\n\nReturns the Molecule{T} associated with the given idx in sys. Throws a KeyError if no such molecule exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.molecules","page":"System representation","title":"BiochemicalAlgorithms.molecules","text":"molecules(sys::System{T}) -> MoleculeTable\n\n\nReturns a MoleculeTable{T} containing all molecules of the given system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nmolecules","page":"System representation","title":"BiochemicalAlgorithms.nmolecules","text":"nmolecules(sys::System) -> Int64\n\n\nReturns the number of molecules in the given system.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_molecule","page":"System representation","title":"BiochemicalAlgorithms.parent_molecule","text":"parent_molecule(::Atom)\nparent_molecule(::Chain)\nparent_molecule(::Fragment)\nparent_molecule(::Nucleotide)\nparent_molecule(::Residue)\n\nReturns the Molecule{T} containing the given object. Returns nothing if no such molecule exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{System{T}, Molecule{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::System{T}, ::Molecule{T})\n\nCreates a copy of the given molecule in the given system. The new molecule is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Chains","page":"System representation","title":"Chains","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Chain\nChainTable\nchain_by_idx\nchains\nnchains\nparent_chain\nBase.push!(::Molecule{T}, ::Chain{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Chain","page":"System representation","title":"BiochemicalAlgorithms.Chain","text":"Chain{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual chain in a system.\n\nPublic fields\n\nidx::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\n\nConstructors\n\nChain(\n    mol::Molecule{T};\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Chain{T} in the given molecule.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.ChainTable","page":"System representation","title":"BiochemicalAlgorithms.ChainTable","text":"ChainTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system chains (or a subset thereof). Chain tables can be generated using chains or filtered from other chain tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.chain_by_idx","page":"System representation","title":"BiochemicalAlgorithms.chain_by_idx","text":"chain_by_idx(sys::System{T}, idx::Int64) -> Chain\n\n\nReturns the Chain{T} associated with the given idx in sys. Throws a KeyError if no such chain exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.chains","page":"System representation","title":"BiochemicalAlgorithms.chains","text":"chains(::Molecule)\nchains(::System; kwargs...)\n\nReturns a ChainTable{T} containing all chains of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing: Any value other than nothing limits the result to chains belonging to the molecule with the given ID.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nchains","page":"System representation","title":"BiochemicalAlgorithms.nchains","text":"nchains(::Molecule)\nnchains(::System; kwargs...)\n\nReturns the number of chains in the given atom container.\n\nSupported keyword arguments\n\nSee chains\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_chain","page":"System representation","title":"BiochemicalAlgorithms.parent_chain","text":"parent_chain(::Atom)\nparent_chain(::Fragment)\nparent_chain(::Nucleotide)\nparent_chain(::Residue)\n\nReturns the Chain{T} containing the given object. Returns nothing if no such chain exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Molecule{T}, Chain{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Molecule{T}, ::Chain{T})\n\nCreates a copy of the given chain in the given molecule. The new chain is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Fragments","page":"System representation","title":"Fragments","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Fragment\nFragmentTable\nfragment_by_idx\nfragments\nnfragments\nparent_fragment\nBase.push!(::Chain{T}, ::Fragment{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Fragment","page":"System representation","title":"BiochemicalAlgorithms.Fragment","text":"Fragment{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual fragment in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nFragment(\n    chain::Chain{T},\n    number::Int;\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Fragment{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.FragmentTable","page":"System representation","title":"BiochemicalAlgorithms.FragmentTable","text":"FragmentTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system fragments (or a subset thereof). Fragment tables can be generated using fragments or filtered from other fragment tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.fragment_by_idx","page":"System representation","title":"BiochemicalAlgorithms.fragment_by_idx","text":"fragment_by_idx(sys::System{T}, idx::Int64) -> Fragment\n\n\nReturns the Fragment{T} associated with the given idx in sys. Throws a KeyError if no such fragment exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.fragments","page":"System representation","title":"BiochemicalAlgorithms.fragments","text":"fragments(::Chain)\nfragments(::Molecule)\nfragments(::System)\n\nReturns a FragmentTable{T} containing all fragments of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to fragments matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nfragments","page":"System representation","title":"BiochemicalAlgorithms.nfragments","text":"nfragments(::Chain)\nnfragments(::Molecule)\nnfragments(::System)\n\nReturns the number of fragments in the given atom container.\n\nSupported keyword arguments\n\nSee fragments\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_fragment","page":"System representation","title":"BiochemicalAlgorithms.parent_fragment","text":"parent_fragment(::Atom)\n\nReturns the Fragment{T} containing the given atom. Returns nothing if no such fragment exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Fragment{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Fragment{T})\n\nCreates a copy of the given fragment in the given chain. The new fragment is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Nucleotides","page":"System representation","title":"Nucleotides","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Nucleotide\nNucleotideTable\nnnucleotides\nnucleotide_by_idx\nnucleotides\nparent_nucleotide\nBase.push!(::Chain{T}, ::Nucleotide{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Nucleotide","page":"System representation","title":"BiochemicalAlgorithms.Nucleotide","text":"Nucleotide{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual nucleotide in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\nname::String\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nNucleotide(\n    chain::Chain{T},\n    number::Int;\n    # keyword arguments\n    name::String = \"\",\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Nucleotide{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.NucleotideTable","page":"System representation","title":"BiochemicalAlgorithms.NucleotideTable","text":"NucleotideTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system nucleotides (or a subset thereof). Nucleotide tables can be generated using nucleotides or filtered from other nucleotide tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\nname::AbstractVector{String}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.nnucleotides","page":"System representation","title":"BiochemicalAlgorithms.nnucleotides","text":"nnucleotides(::Chain)\nnnucleotides(::Molecule)\nnnucleotides(::System)\n\nReturns the number of nucleotides in the given atom container.\n\nSupported keyword arguments\n\nSee nucleotides\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nucleotide_by_idx","page":"System representation","title":"BiochemicalAlgorithms.nucleotide_by_idx","text":"nucleotide_by_idx(sys::System{T}, idx::Int64) -> Nucleotide\n\n\nReturns the Nucleotide{T} associated with the given idx in sys. Throws a KeyError if no such nucleotide exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.nucleotides","page":"System representation","title":"BiochemicalAlgorithms.nucleotides","text":"nucleotides(::Chain)\nnucleotides(::Molecule)\nnucleotides(::System)\n\nReturns a NucleotideTable{T} containing all nucleotides of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to nucleotides matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_nucleotide","page":"System representation","title":"BiochemicalAlgorithms.parent_nucleotide","text":"parent_nucleotide(::Atom)\n\nReturns the Nucleotide{T} containing the given atom. Returns nothing if no such nucleotide exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Nucleotide{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Nucleotide{T})\n\nCreates a copy of the given nucleotide in the given chain. The new nucleotide is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"public/system/#Residues","page":"System representation","title":"Residues","text":"","category":"section"},{"location":"public/system/","page":"System representation","title":"System representation","text":"Residue\nResidueTable\nnresidues\nparent_residue\nresidue_by_idx\nresidues\nBase.push!(::Chain{T}, ::Residue{T}) where T","category":"page"},{"location":"public/system/#BiochemicalAlgorithms.Residue","page":"System representation","title":"BiochemicalAlgorithms.Residue","text":"Residue{T} <: AbstractAtomContainer{T}\n\nMutable representation of an individual residue in a system.\n\nPublic fields\n\nidx::Int\nnumber::Int\ntype::AminoAcid\n\nPrivate fields\n\nproperties::Properties\nflags::Flags\nmolecule_idx::Int\nchain_idx::Int\n\nConstructors\n\nResidue(\n    chain::Chain{T},\n    number::Int,\n    type::AminoAcid;\n    # keyword arguments\n    properties::Properties = Properties(),\n    flags::Flags = Flags()\n)\n\nCreates a new Residue{T} in the given chain.\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.ResidueTable","page":"System representation","title":"BiochemicalAlgorithms.ResidueTable","text":"ResidueTable{T} <: AbstractSystemComponentTable{T}\n\nTables.jl-compatible representation of system residues (or a subset thereof). Residue tables can be generated using residues or filtered from other residue tables (via Base.filter).\n\nPublic columns\n\nidx::AbstractVector{Int}\nnumber::AbstractVector{Int}\ntype::AbstractVector{AminoAcid}\n\nPrivate columns\n\nproperties::AbstractVector{Properties}\nflags::AbstractVector{Flags}\nmolecule_idx::AbstractVector{Int}\nchain_idx::AbstractVector{Int}\n\n\n\n\n\n","category":"type"},{"location":"public/system/#BiochemicalAlgorithms.nresidues","page":"System representation","title":"BiochemicalAlgorithms.nresidues","text":"nresidues(::Chain)\nnresidues(::Molecule)\nnresidues(::System)\n\nReturns the number of residues in the given atom container.\n\nSupported keyword arguments\n\nSee residues\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.parent_residue","page":"System representation","title":"BiochemicalAlgorithms.parent_residue","text":"parent_residue(::Atom)\n\nReturns the Residue{T} containing the given atom. Returns nothing if no such residue exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.residue_by_idx","page":"System representation","title":"BiochemicalAlgorithms.residue_by_idx","text":"residue_by_idx(sys::System{T}, idx::Int64) -> Residue\n\n\nReturns the Residue{T} associated with the given idx in sys. Throws a KeyError if no such residue exists.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#BiochemicalAlgorithms.residues","page":"System representation","title":"BiochemicalAlgorithms.residues","text":"residues(::Chain)\nresidues(::Molecule)\nresidues(::System)\n\nReturns a ResidueTable{T} containing all residues of the given atom container.\n\nSupported keyword arguments\n\nmolecule_idx::MaybeInt = nothing\nchain_idx::MaybeInt = nothing\n\nAll keyword arguments limit the results to residues matching the given IDs. Keyword arguments set to nothing are ignored.\n\n\n\n\n\n","category":"function"},{"location":"public/system/#Base.push!-Union{Tuple{T}, Tuple{Chain{T}, Residue{T}}} where T","page":"System representation","title":"Base.push!","text":"push!(::Chain{T}, ::Residue{T})\n\nCreates a copy of the given residue in the given chain. The new residue is automatically assigned a new idx.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/read_and_write/#All-on-Input-and-Output","page":"read and write","title":"All on Input and Output","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"BiochemicalAlgorithms.jl supports the reading and writing of several common structural data formats.","category":"page"},{"location":"tutorials/read_and_write/#Protein-Data-Bank-Format-(PDB)","page":"read and write","title":"Protein Data Bank Format (PDB)","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"The most common format ist the PDB. Have a look at Learning about PDB data if you want to refresh your knowledge about this format. For a deeper understanding you can also read PDB format specifications.","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"using BiochemicalAlgorithms","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"# Read PDB file from the BiochemicalAlgorithms.jl repository\npdb_sys = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\n\nfor atom in atoms(pdb_sys)\n    if atom.element == Elements.S\n        print(atom.number)\n    end\nend\n\nfdb = FragmentDB()\n\nnormalize_names!(pdb_sys,fdb)\nreconstruct_fragments!(pdb_sys, fdb)\nbuild_bonds!(pdb_sys, fdb)\nwrite_pdb(\"Ala_out.pdb\", pdb_sys)","category":"page"},{"location":"tutorials/read_and_write/#PubChem","page":"read and write","title":"PubChem","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"In addition to PDB, the pubchem data base plays an important role as a source of structural data. Pubchem allows to retrieve data in JSON which is read by BiochemicalAlgorithms.jl as shown below:","category":"page"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"pubchem_sys = load_pubchem_json(ball_data_path(\"../test/data/aspirin_pug.json\"))\n\nfdb = FragmentDB()\nnormalize_names!(pdb_sys,fdb)\nreconstruct_fragments!(pdb_sys, fdb)\nbuild_bonds!(pdb_sys, fdb)\n\nfor atom in atoms(pdb_sys)\n    if atom.element == Elements.S\n        println(atom.number)\n    end\nend","category":"page"},{"location":"tutorials/read_and_write/#SD-file","page":"read and write","title":"SD file","text":"","category":"section"},{"location":"tutorials/read_and_write/","page":"read and write","title":"read and write","text":"sd_sys = load_sdfile(ball_data_path(\"../test/data/rings_test.sdf\"))\n\nfdb = FragmentDB()\nnormalize_names!(sd_sys,fdb)\nreconstruct_fragments!(sd_sys, fdb)\nbuild_bonds!(sd_sys, fdb)\n\nfor atom in atoms(sd_sys)\n    if atom.element == Elements.S\n        println(atom.number)\n    end\nend\n\nwrite_sdfile(ball_data_path(\"../test/data/rings_test_out.sdf\"), sd_sys)","category":"page"},{"location":"tutorials/iterate/#All-on-iteration","page":"iterate","title":"All on iteration","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"When working with molecular entities, we want to run over all atoms of a system, over all chains, … in this tutorial we will learn how this can be done.","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"using BiochemicalAlgorithms","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":":::{cell .markdown} # Molecular systems In BiochemicalAlgorithms.jl atoms and bonds are existing inside a System. Typically, molecular data is stored in molecular data formats such as PDB. The latter can be directly read into a system.","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"s = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\nnatoms(s)","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-atoms-of-a-system?","page":"iterate","title":"How can I iterate over all atoms of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"We can easily iterate over all atoms of this system.","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"for a in atoms(s)\n    println(a.name)\nend","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# we can actually write\nprintln.(a.name for a in atoms(s))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-specific-atoms?","page":"iterate","title":"How can I iterate over specific atoms?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"In many scenarios, we only want to iterate over a subset of atoms fulfilling a specific criteria. For example, we only want to get the positions of the Calpha-atoms or we only want the heavy atoms: :::","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.(a.r for a in atoms(s) if a.name == \"CA\")","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"heavy_atoms = filter(atom -> atom.element != Elements.H, atoms(s))\n# natoms(s)\nlength(heavy_atoms)\nheavy_atoms","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"The filtering process gives us an AtomTable:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"typeof(s)\ntypeof(atoms(s))\ntypeof(heavy_atoms)","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-atoms-of-a-molecule?","page":"iterate","title":"How can I iterate over all atoms of a molecule?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Sometimes it is preferably to iterate over a molecule (e.g., in docking scenarios where you only want to iterate over receptor atoms).","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# generate a molecule\nmol = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\nprintln.(a.name for a in atoms(mol))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-bonds-of-a-system?","page":"iterate","title":"How can I iterate over all bonds of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Bonds are not explicitely stored in the PDB format but are rather inferred after reading the data into a system using the Fragment Database:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"# bonds are not contained in the pdb\nnbonds(s)\n\n# use the fragment data base for normalizing naming schemas between molecular file formats, reconstruction of missing parts of the structure and building the bonds\nfdb = FragmentDB()\n\nnormalize_names!(s, fdb)\nreconstruct_fragments!(s, fdb)\nbuild_bonds!(s, fdb)\nnbonds(s)","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Similar to the atom iteration, we can iterate over all bonds of a sysem:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.(b.order for b in bonds(s))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-bonds-of-an-atom?","page":"iterate","title":"How can I iterate over all bonds of an atom?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"Or only iterate over the bonds of a specific atom:","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"atom = first(atoms(s)) \nbds = filter(bond -> bond.a1 == atom.idx || bond.a2 == atom.idx, bonds(s))\nprintln.(b for b in bds)","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-chains-of-a-system?","page":"iterate","title":"How can I iterate over all chains of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"We can get the name and the number of atoms per chain by the following","category":"page"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.((chain.name, length(atoms(chain))) for chain in chains(s))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-chains-of-a-molecule?","page":"iterate","title":"How can I iterate over all chains of a molecule?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.((chain.name, length(atoms(chain))) for chain in chains(mol))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-residues-of-a-system?","page":"iterate","title":"How can I iterate over all residues of a system?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.(res.type for res in residues(s))\n\nprintln.(res.chain_idx for res in fragments(s))","category":"page"},{"location":"tutorials/iterate/#How-can-I-iterate-over-all-residues-of-a-chain?","page":"iterate","title":"How can I iterate over all residues of a chain?","text":"","category":"section"},{"location":"tutorials/iterate/","page":"iterate","title":"iterate","text":"println.(res.type for res in residues(chain_by_idx(s,2)))","category":"page"},{"location":"private/system/#Model","page":"System representation","title":"Model","text":"","category":"section"},{"location":"private/system/","page":"System representation","title":"System representation","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"private/system/","page":"System representation","title":"System representation","text":"Pages = [\"system.md\"]","category":"page"},{"location":"private/system/","page":"System representation","title":"System representation","text":"_default_system\n_next_idx","category":"page"},{"location":"private/system/#BiochemicalAlgorithms._default_system","page":"System representation","title":"BiochemicalAlgorithms._default_system","text":"const _default_system\n\nGlobal default system.\n\n\n\n\n\n","category":"constant"},{"location":"private/system/#BiochemicalAlgorithms._next_idx","page":"System representation","title":"BiochemicalAlgorithms._next_idx","text":"_next_idx(sys::System{T}) -> Int64\n\n\nReturns the next available idx for the given system.\n\n\n\n\n\n","category":"function"},{"location":"private/mappings/#Mappings","page":"Mappings","title":"Mappings","text":"","category":"section"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"Pages = [\"mappings.md\"]","category":"page"},{"location":"private/mappings/","page":"Mappings","title":"Mappings","text":"_compute_rotation","category":"page"},{"location":"private/mappings/#BiochemicalAlgorithms._compute_rotation","page":"Mappings","title":"BiochemicalAlgorithms._compute_rotation","text":"_compute_rotation(\n    R::StaticArraysCore.SArray{Tuple{3, 3}, T<:Real, 2},\n    _::Type{RMSDMinimizerKabsch}\n) -> Any\n\n\nComputes the rotation matrix by solving the eigen value problem given as the correlation matrix C. Uses all resulting eigenvalues and eigenvectors. Warns if the correlation matrix is not positive definit (contains negative eigenvalues or eigenvalues equal to 0) and uses the alternative approch RMSDMinimizerCoutsias instead. Returns a RotMatrix3.\n\n\n\n\n\n_compute_rotation(\n    R::StaticArraysCore.SArray{Tuple{3, 3}, T<:Real, 2},\n    _::Type{RMSDMinimizerCoutsias}\n) -> Rotations.RotMatrix3{T} where T<:Real\n\n\nComputes the rotation matrix by solving the eigen value problem given as the residual matrix F. Uses only the largest of the resulting eigenvalues to generate the Quaternion describing the  optimal rotation that maps the atoms onto each other. Returns a RotMatrix3.\n\n\n\n\n\n","category":"function"},{"location":"public/forcefields/#Force-fields","page":"Force fields","title":"Force fields","text":"","category":"section"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"Pages = [\"forcefields.md\"]","category":"page"},{"location":"public/forcefields/","page":"Force fields","title":"Force fields","text":"update!\nread_ball_ini_file","category":"page"},{"location":"public/forcefields/#BiochemicalAlgorithms.update!","page":"Force fields","title":"BiochemicalAlgorithms.update!","text":"Update the internal data structures of the force field when the system changes    (e.g., through coordinate updates)\n\nPlease note that changes to the options or the topology require a call to setup!prior to the call toupdate``.\n\n\n\n\n\n","category":"function"},{"location":"public/forcefields/#BiochemicalAlgorithms.read_ball_ini_file","page":"Force fields","title":"BiochemicalAlgorithms.read_ball_ini_file","text":"read_ball_ini_file(path::String; ...) -> BALLIniFile\nread_ball_ini_file(\n    path::String,\n    T;\n    cleanup_keys\n) -> BALLIniFile\n\n\nRead a file in BALL's old Ini file format and return it as a BALLIniFile.\n\nIf cleanup_keys is set to true (the default), keys into the Ini sections are simplified (e.g., ver:version becomes version, key:I becomes I, ...).\n\n\n\n\n\n","category":"function"},{"location":"tutorials/handle_molecules/#All-on-Handling-molecules","page":"handle molecules","title":"All on Handling molecules","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"using BiochemicalAlgorithms","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-create-a-simple-molecule?","page":"handle molecules","title":"How can I create a simple molecule?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"# create a system first\nsys = System{Float32}() # this system will be of single precision, i.e., atom positions, velocities... \n\n# as well as a molecule\nh2o = Molecule(sys)\n\n# create system atoms\no1 = Atom(h2o, 1, Elements.O)\nh1 = Atom(h2o, 2, Elements.H)\nh2 = Atom(h2o, 3, Elements.H)\n\n# set positions of the atoms\n# o1.r = [0, 0, 0]  <-- this is the default value!\nh1.r = [1, 0, 0]\nh2.r = [cos(deg2rad(105)), sin(deg2rad(105)), 0)\n\n# add bonds\nBond(h2o, o1.idx, h1.idx, BondOrder.Single)\nBond(h2o, o1.idx, h2.idx, BondOrder.Single)\n\nprintln(\"Number of atoms: \", natoms(h2o))\nprintln(\"Number of bonds: \", nbonds(h2o))","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-determine-the-element-type-of-an-atom-(i.e.,-C,N,…)?","page":"handle molecules","title":"How can I determine the element type of an atom (i.e., C,N,…)?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"s = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\n\nfor atom in atoms(s)\n    if atom.element == Elements.C\n        println(\"This is a carbon atom!\")\n    end\nend","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-identify-backbone-atoms?","page":"handle molecules","title":"How can I identify backbone atoms?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"s = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\n\nfor atom in atoms(s)\n    println(atom.element)\n    if atom.name in [\"C\", \"O\", \"N\", \"HA\"]\n        println(\"This is a backbone atom!\")\n    end\nend","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-get-the-one-letter-code-out-of-a-PDB-file?","page":"handle molecules","title":"How can I get the one-letter code out of a PDB file?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"s = load_pdb(ball_data_path(\"../test/data/AlaAla.pdb\"))\nfor chain in chains(sys)\n    print.(res.type for res in residues(sys))\nend","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-pick-one-single-chain-out-of-a-system-containing-several-chains?","page":"handle molecules","title":"How can I pick one single chain out of a system containing several chains?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"This is often needed when a receptor and a ligand are co-complexed and you want to treat them separately. This snippet will create copies of the first two chains and strores them in separate pdb files.","category":"page"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"sys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\nchainA = deepcopy(chains(sys)[1])\nchainB = deepcopy(chains(sys)[2])\n\nwrite_pdb(\"2ptc_chainA.pdb\", chainA)\nwrite_pdb(\"2ptc_chainB.pdb\", chainB)","category":"page"},{"location":"tutorials/handle_molecules/#How-can-I-map-two-configurations-of-the-same-protein-onto-each-other?","page":"handle molecules","title":"How can I map two configurations of the same protein onto each other?","text":"","category":"section"},{"location":"tutorials/handle_molecules/","page":"handle molecules","title":"handle molecules","text":"# read in the first protein\nsys = load_pdb(ball_data_path(\"../test/data/2ptc.pdb\"))\nmol = first(molecules(sys))\n\n# we will generate a second version of the protein by moving it around\nsys2 = deepcopy(sys)\nmol2 = first(molecules(sys2))\ntranslate!(mol2, Vector3{Float32}(2.0,1.0,2.0))\n\n# let's see how far the structures are apart\nprintln(compute_rmsd(mol2, mol))\n\n# now we have two proteins or system we can map together\nmap_rigid!(mol2, mol)\n\n# let's see how far the structures are apart afterwards\nprintln(compute_rmsd(mol2, mol))","category":"page"},{"location":"tutorials/getting_started/#Welcome-to-BiochemicalAlgorithms.jl","page":"get started","title":"Welcome to BiochemicalAlgorithms.jl","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"In this tutorial, you will learn about the basic concepts of the BiochemicalAlgorithms.jl-library (sometimes shortened to BALL.jl) – a complete rewrite of the C++-framework BALL in Julia.","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"To use BiochemicalAlgorithms.jl in your code, add it to your project","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"import Pkg\nPkg.add(url=\"https://github.com/hildebrandtlab/BiochemicalAlgorithms.jl\")","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"and use it in your code:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"using BiochemicalAlgorithms","category":"page"},{"location":"tutorials/getting_started/#Representing-molecular-systems","page":"get started","title":"Representing molecular systems","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"In BiochemicalAlgorithms.jl, all molecules are stored in so-called Systems. While a System can be created from scratch and filled programmatically, it is commonly created by reading a molecular file, such as a PDB-file:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"s = load_pdb(\"data/5PTI.pdb\")","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"System with 1087 atoms (5PTI.pdb)","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"You can then run methods on this system, e.g.","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"println(\"The system $(s.name) contains $(natoms(s)) atoms.\")","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"The system 5PTI.pdb contains 1087 atoms.","category":"page"},{"location":"tutorials/getting_started/#Common-preparation-steps","page":"get started","title":"Common preparation steps","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"The data stored in many molecular file formats is incomplete, or needs to be normalized in certain ways. PDB-files, for instance, often omit hydrogen atoms, and don’t usually store bonds that can be inferred otherwise. BiochemicalAlgorithms.jl offers a number of methods that perform preparation steps that are common to most molecular modelling applications, such as normalizing atom- and fragment names, computing bonds, adding missing atoms from a library of templates (such as amino acids), or saturating a molecule with hydrogen atoms. The template information used by these methods is stored in the so-called FragmentDB. A common series of operations to prepare a system for further processing is as follows:","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"fdb = FragmentDB()\n\nnormalize_names!(s, fdb)\nreconstruct_fragments!(s, fdb)\nbuild_bonds!(s, fdb)","category":"page"},{"location":"tutorials/getting_started/","page":"get started","title":"get started","text":"[ Info: reconstruct_fragments!(): added 109 atoms.\n[ Info: build_bonds!(): built 912 bonds","category":"page"},{"location":"public/mappings/#Mappings","page":"Mappings","title":"Mappings","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"Pages = [\"mappings.md\"]","category":"page"},{"location":"public/mappings/#Atom-bijection","page":"Mappings","title":"Atom bijection","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"AbstractAtomBijection\nTrivialAtomBijection","category":"page"},{"location":"public/mappings/#BiochemicalAlgorithms.AbstractAtomBijection","page":"Mappings","title":"BiochemicalAlgorithms.AbstractAtomBijection","text":"abstract type AbstractAtomBijection{T}\n\nAbstract base type for AtomBijections.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.TrivialAtomBijection","page":"Mappings","title":"BiochemicalAlgorithms.TrivialAtomBijection","text":"TrivialAtomBijection{T} <: AbstractAtomBijection{T}\n\nMutable representation of a bijection of atoms based on the order of atoms in the individual atom containers.\n\nPublic fields\n\natoms_A::AtomTable{T}\natoms_B::AtomTable{T}\n\nConstructors\n\nTrivialAtomBijection{T}(A::AbstractAtomContainer{T}, B::AbstractAtomContainer{T}) where T\n\nCreates a new TrivialAtomBijection{T} with the atoms of the individual atom containers. \n\nTrivialAtomBijection{T}(atoms_A, B::AbstractAtomContainer{T}) where T\n\nCreates a new TrivialAtomBijection{T}based on the unique set of atom numbers of atoms_A.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#Rigid-Mapping","page":"Mappings","title":"Rigid Mapping","text":"","category":"section"},{"location":"public/mappings/","page":"Mappings","title":"Mappings","text":"AbstractRMSDMinimizer\nRMSDMinimizerCoutsias\nRMSDMinimizerKabsch\nRigidTransform\ncompute_rmsd\ncompute_rmsd_minimizer\nmap_rigid!\nmatch_points\nrigid_transform!\ntranslate!","category":"page"},{"location":"public/mappings/#BiochemicalAlgorithms.AbstractRMSDMinimizer","page":"Mappings","title":"BiochemicalAlgorithms.AbstractRMSDMinimizer","text":"abstract type AbstractRMSDMinimizer\n\nAbstract base type for rmsd minimizer.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RMSDMinimizerCoutsias","page":"Mappings","title":"BiochemicalAlgorithms.RMSDMinimizerCoutsias","text":"abstract type RMSDMinimizerCoutsias <: AbstractRMSDMinimizer\n\nAbstract base type for minimizer as described by Coutsias et al., which is used as default.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RMSDMinimizerKabsch","page":"Mappings","title":"BiochemicalAlgorithms.RMSDMinimizerKabsch","text":"abstract type RMSDMinimizerKabsch <: AbstractRMSDMinimizer\n\nAbstract base type for minimizer as described by Kabsch.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.RigidTransform","page":"Mappings","title":"BiochemicalAlgorithms.RigidTransform","text":"struct RigidTransform{T<:Real}\n\nMutable representation of a rigid transform.\n\nFields\n\nrotation::RotMatrix3\ntranslation::Vector3\n\nConstructors\n\nRigidTransform{T}(r::RotMatrix3{T}, t::Vector3{T}) where {T<:Real}\n\nCreates a new RigidTransform{T} with the given parameters.\n\nRigidTransform{T}(r::Matrix3{T}, t::Vector3{T}) where {T<:Real} \n\nCreates a new RigidTransform{T} and converts the given Matrix3{T} to a RotMatrix3 object.\n\nnote: Note\nFrom the documentation of Rotations.jl:The given Matrix3{T} should have the property I =RR^T, but this isn't enforced by the constructor.\n\nRigidTransform(r::Matrix3, t::Vector3) = RigidTransform{Float32}(r, t)\n\nCreates a new RigidTransform{Float32} with the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"public/mappings/#BiochemicalAlgorithms.compute_rmsd","page":"Mappings","title":"BiochemicalAlgorithms.compute_rmsd","text":"compute_rmsd(f::AbstractAtomBijection{T<:Real}) -> Any\n\n\nComputes the root mean square deviation (RMSD) of the given AbstractAtomBijection.\n\n\n\n\n\ncompute_rmsd(\n    A::AbstractAtomContainer,\n    B::AbstractAtomContainer\n) -> Any\n\n\nComputes the root mean square deviation (RMSD) based on two sets of atoms.\n\nnote: Note\nAtomContainers must have the same number of atoms.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.compute_rmsd_minimizer","page":"Mappings","title":"BiochemicalAlgorithms.compute_rmsd_minimizer","text":"compute_rmsd_minimizer(\n    f::AbstractAtomBijection{T<:Real}\n) -> RigidTransform\ncompute_rmsd_minimizer(\n    f::AbstractAtomBijection{T<:Real},\n    mini::Type{<:AbstractRMSDMinimizer}\n) -> RigidTransform\n\n\nComputes the transformation required to map two atom sets given as the atom bijection.\n\nReturns a RigidTransformation object. The translation is given by the difference of the means of the atom sets. The corresponding rotation matrix can be computed by the approach of Coutsias et al. (default) or Kabsch, implemented by RMSDMinimizerCoutsias and RMSDMinimizerKabsch, respectively.  Both implementation rely on solving an eigen value problem. Coutsias et al. represents rotation matrices as quaternions (use of Package Quaternions.jl).\n\nnote: Note\nIn order to map the two atom sets with the resulting RigidTransform the system to be mapped hast to be transferred to the origin first (before the RigidTransform is applied).\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.map_rigid!","page":"Mappings","title":"BiochemicalAlgorithms.map_rigid!","text":"map_rigid!(\n    A::AbstractAtomContainer{T<:Real},\n    B::AbstractAtomContainer{T<:Real};\n    heavy_atoms_only\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nMaps AbstractAtomContainer A onto AbstractAtomContainer B by first moving A to the origin and then computing the RigidTransform by using RMSDMinimizerCoutsias. Returns the mapped AbstractAtomContainer A.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.match_points","page":"Mappings","title":"BiochemicalAlgorithms.match_points","text":"match_points(\n    w1::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    w2::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    w3::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v1::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v2::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3},\n    v3::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3}\n) -> Tuple{Any, Any}\n\n\nThe transformation maps\n\nthe point w1 onto the point v1 and\nthe point w2 onto the ray that starts in v1 and goes through v2\nthe point w3 into the plane generated by v1, v2 and v3\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.rigid_transform!","page":"Mappings","title":"BiochemicalAlgorithms.rigid_transform!","text":"rigid_transform!(\n    m::AbstractAtomContainer{T<:Real},\n    transform::RigidTransform{T<:Real}\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nPerforms a rigid transformation on the atom positions of m.  First, atoms are rotated by the rotation matrix of the RigidTransform r followed by translation.\n\n\n\n\n\n","category":"function"},{"location":"public/mappings/#BiochemicalAlgorithms.translate!","page":"Mappings","title":"BiochemicalAlgorithms.translate!","text":"translate!(\n    m::AbstractAtomContainer{T<:Real},\n    t::StaticArraysCore.SArray{Tuple{3}, T<:Real, 1, 3}\n) -> AbstractAtomContainer{T} where T<:Real\n\n\nMoves the atoms of the atom container to new positions by adding the values given by the vector t the current positions.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BiochemicalAlgorithms","category":"page"},{"location":"#BiochemicalAlgorithms","page":"Home","title":"BiochemicalAlgorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BiochemicalAlgorithms.","category":"page"}]
}
